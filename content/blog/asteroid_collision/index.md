---
layout: layouts/post.njk
title: Столкновение астероидов
date: 2023-12-11
complexity: medium
original_url: https://leetcode.com/problems/asteroid-collision/
preview_image: /images/previews/asteroid_collision.webp
tags:
  - medium
  - array
  - stack
---
---

## Описание задачи

Напишите функцию, которая будет рассчитывать результаты столкновения астероидов.

**Входные данные**

Массив целых ненулевых чисел. Каждое число обозначает массу астероида, знак — направление движения.

**Выходные данные**

Массив целых ненулевых чисел. Массив будет описывать множество астероидов, их массу и направление, после того как все астероиды, которые могут столкнуться, столкнутся. 

Все астероиды движутся с одинаковой скоростью. Таким образом, астероиды, летящие в одном направлении никогда не столкнутся друг с другом.

В отличие от реальной жизни, при столкновении масса и направление движения астероидов после никак не изменяется. Меньший из двух полностью уничтожается, больший продолжает лететь в прежнем направлении, не меняя массу.

---

## Ограничения

- Количество астероидов (длина входного массива) находится в диапазоне от 2 до 10000
- Масса астероида лежит в диапазоне от 1 до 1000 (знак влияет только на направление движения)
- Астероидов с нулевой массой не существует

---

## Примеры

{% tabs %}

{% tab "Пример №1" %}

**Входные данные**: `[5,10,-5]`

**Ответ**: `[5,10]`

**Пояснение**: Первые два астероида движутся вправо, последний - влево. В результате, второй и третий астероид должны столкнуться. Второй астероид имеет большую массу, поэтому он полностью уничтожит третий.

{% endtab %}

{% tab "Пример №2" %}

**Входные данные**: `[8,-8]`

**Ответ**: `[]`

**Пояснение**: Астероиды движутся навстречу друг другу и имеют одинаковую массу. В результате оба астероида будут уничтожены.

{% endtab %}

{% tab "Пример №3" %}

**Входные данные**: `[10,2,-5]`

**Ответ**: `[10]`

**Пояснение**: Первые два астероида движутся вправо, последний - влево. В результате, третий астероид уничтожит второй. и продолжит движение влево. После этого столкнуться первый и третий астероиды, а так как первый имеет большую массу, он уничтожит третий.

{% endtab %}
{% endtabs %}

---

## Решение через два указателя

Одно из возможных решений - использовать два указателя. В качестве первых точек выбираем первые два астероида. Действуем по следующему принципу:
- Если левый астероид имеет отрицательный знак (то есть астероид летит влево), перемещаем оба указателя на единицу вперед.
- Если оба астероида имеют положительный знак (то есть оба летят вправо), перемещаем оба указателя на единицу вперед, так как летят в одном направлении и никогда не столкнуться друг с другом.
- Если левый астероид имеет положительный знак, а правый отрицательный:
  - Если левый астероид по модулю больше правого - вырезаем элемент, на который указывает правый индекс, индексы не смещаем, так как после смещения правый индекс указывает на астероид, стоявший за вырезанным элементом.
  - Если правый астероид по модулю меньше - вырезаем элемент, на который указывает левый индекс, оба индекса уменьшаем на единицу, так как в результате смещения правый элемент сместился на один влево, а левый мы вырезали.
  - Если астероиды по модулю равны - вырезаем оба элемента. Оба индекса уменьшаем на единицу, так как в данном случае нам нужно сдвинуть левый на единицу назад, правый на единицу вперед, но в результате смещения на два элемента влево, правый индекс также нужно будет уменьшить на две единицы.
- Не забываем проверить корнер кейсы: в результате наших манипуляций, индексы могут выйти за диапазон `[0, len(asteroids)]`.

{% renderFile "_includes/components/solution.njk", taskName = "asteroid_collision", fileName="solution_two_idx" %}

### Оценка сложности

**По времени**

Сложность <code>O(n<sup>2</sup>)</code>, где `n` — длина строки. 

Несмотря на то, что мы работали с двумя указателями и не запускали внутренних циклов, стоит вспомнить, что операция вырезания элемента из середины массива оценивается как `O(n)` (так как весь «хвост» массива нужно сдвинуть на один элемент влево).

**По памяти**

Сложность `O(1)`, так как все изменения мы делали in-place, без выделения доп памяти.

---

## Решение через стек

Задачу можно решить за линейное время с использованием структуры данных стек.

Основная идея решения мало чем отличается от задачи по валидации скобочной последовательности, которую мы [разбирали ранее](/blog/valid_parentheses).

Для решения задачи, нам необходимо завести стек (можно реализовать стек через массив) и в цикле перебрать элементы исходного массива:
- Если стек пустой, добавляем элемент в стек.
- Если стек не пустой, извлекаем верхний элемент. Если он имеет отрицательный знак (то есть астероид летит влево), возвращаем в стек, а также добавляем в стек текущий элемент.
- Если стек не пустой, извлекаем верхний элемент. Если он положительный, а текущий элемент отрицательный, то:
  - Если текущий элемент имеет меньшую массу, возвращаем верхний элемент обратно в стек и переходим к следующему элементу.
  - Если элементы имеют одинаковую массу, переходим к следующему элементу, не возвращая верхний элемент в стек.
  - Если текущий элемент имеет меньшую массу, извлекаем следующий элемент из стека, не возвращая верхний элемент в стек и повторяем проверки с новой парой.
- После того как мы полностью проитерируемся по всем элементам исходного массива, в стеке будет находиться ожидаемый набор астероидов. Если стек реализован через массив, функция может вернуть его в качестве ответа.

Для простоты мы реализовали этот подход через рекурсивную функцию `appendAsteroidToStack`, но, можно обойтись и без рекурсии.

{% renderFile "_includes/components/solution.njk", taskName = "asteroid_collision" %}

### Оценка сложности

**По времени**

Сложность `O(n)`, где `n` — длина строки.

В худшем случае нам придется положить `n-1` элементов в стек, а после извлечь все элементы. То есть, максимальная сложность равна `2n`, что с точки зрения оценки алгоритма эквивалентно `O(n)`.

**По памяти**

Сложность `O(n)`, так как нам пришлось создать стек для хранения данных.
